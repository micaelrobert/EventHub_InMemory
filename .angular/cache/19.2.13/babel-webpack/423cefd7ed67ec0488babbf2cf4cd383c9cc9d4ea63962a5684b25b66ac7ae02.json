{"ast":null,"code":"export { _ as _MatInternalFormField } from './internal-form-field-grv62mCZ.mjs';\nimport * as i0 from '@angular/core';\nimport { Version, inject, Injectable, NgModule } from '@angular/core';\nexport { a as MATERIAL_SANITY_CHECKS, M as MatCommonModule } from './common-module-WayjW0Pb.mjs';\nexport { _ as _ErrorStateTracker } from './error-state-Dtb1IHM-.mjs';\nimport { D as DateAdapter, M as MAT_DATE_LOCALE, a as MAT_DATE_FORMATS } from './date-formats-K6TQue-Y.mjs';\nexport { b as MAT_DATE_LOCALE_FACTORY } from './date-formats-K6TQue-Y.mjs';\nexport { E as ErrorStateMatcher, S as ShowOnDirtyErrorStateMatcher } from './error-options-Dm2JJUbF.mjs';\nexport { _ as _StructuralStylesLoader } from './structural-styles-BQUT6wsL.mjs';\nexport { M as MatLine, a as MatLineModule, s as setLines } from './line-Bm3zUbBF.mjs';\nexport { d as MAT_OPTGROUP, c as MAT_OPTION_PARENT_COMPONENT, a as MatOptgroup, M as MatOption, e as MatOptionSelectionChange, _ as _countGroupLabelsBeforeOption, b as _getOptionScrollPosition } from './option-ChV6uQgD.mjs';\nexport { M as MatOptionModule } from './index-DOxJc1m4.mjs';\nexport { M as MatRippleLoader } from './ripple-loader-Ce3DAhPW.mjs';\nexport { a as MAT_RIPPLE_GLOBAL_OPTIONS, M as MatRipple, c as RippleRef, R as RippleRenderer, b as RippleState, d as defaultRippleAnimationConfig } from './ripple-BT3tzh6F.mjs';\nexport { M as MatRippleModule } from './index-SYVYjXwK.mjs';\nexport { M as MatPseudoCheckbox } from './pseudo-checkbox-CJ7seqQH.mjs';\nexport { M as MatPseudoCheckboxModule } from './pseudo-checkbox-module-CAX2sutq.mjs';\nimport '@angular/cdk/a11y';\nimport '@angular/cdk/bidi';\nimport 'rxjs';\nimport 'rxjs/operators';\nimport '@angular/cdk/keycodes';\nimport '@angular/cdk/private';\nimport '@angular/common';\nimport '@angular/cdk/platform';\nimport '@angular/cdk/coercion';\n\n/** Current version of Angular Material. */\nconst VERSION = /*#__PURE__*/new Version('19.2.17');\n\n/**\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n * @docs-private\n */\nlet AnimationCurves = /*#__PURE__*/(() => {\n  class AnimationCurves {\n    static STANDARD_CURVE = 'cubic-bezier(0.4,0.0,0.2,1)';\n    static DECELERATION_CURVE = 'cubic-bezier(0.0,0.0,0.2,1)';\n    static ACCELERATION_CURVE = 'cubic-bezier(0.4,0.0,1,1)';\n    static SHARP_CURVE = 'cubic-bezier(0.4,0.0,0.6,1)';\n  }\n  return AnimationCurves;\n})();\n/**\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n * @docs-private\n */\nlet AnimationDurations = /*#__PURE__*/(() => {\n  class AnimationDurations {\n    static COMPLEX = '375ms';\n    static ENTERING = '225ms';\n    static EXITING = '195ms';\n  }\n  return AnimationDurations;\n})();\n/**\n * Matches strings that have the form of a valid RFC 3339 string\n * (https://tools.ietf.org/html/rfc3339). Note that the string may not actually be a valid date\n * because the regex will match strings with an out of bounds month, date, etc.\n */\nconst ISO_8601_REGEX = /^\\d{4}-\\d{2}-\\d{2}(?:T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|(?:(?:\\+|-)\\d{2}:\\d{2}))?)?$/;\n/**\n * Matches a time string. Supported formats:\n * - {{hours}}:{{minutes}}\n * - {{hours}}:{{minutes}}:{{seconds}}\n * - {{hours}}:{{minutes}} AM/PM\n * - {{hours}}:{{minutes}}:{{seconds}} AM/PM\n * - {{hours}}.{{minutes}}\n * - {{hours}}.{{minutes}}.{{seconds}}\n * - {{hours}}.{{minutes}} AM/PM\n * - {{hours}}.{{minutes}}.{{seconds}} AM/PM\n */\nconst TIME_REGEX = /^(\\d?\\d)[:.](\\d?\\d)(?:[:.](\\d?\\d))?\\s*(AM|PM)?$/i;\n/** Creates an array and fills it with values. */\nfunction range(length, valueFunction) {\n  const valuesArray = Array(length);\n  for (let i = 0; i < length; i++) {\n    valuesArray[i] = valueFunction(i);\n  }\n  return valuesArray;\n}\n/** Adapts the native JS Date for use with cdk-based components that work with dates. */\nlet NativeDateAdapter = /*#__PURE__*/(() => {\n  class NativeDateAdapter extends DateAdapter {\n    /**\n     * @deprecated No longer being used. To be removed.\n     * @breaking-change 14.0.0\n     */\n    useUtcForDisplay = false;\n    /** The injected locale. */\n    _matDateLocale = inject(MAT_DATE_LOCALE, {\n      optional: true\n    });\n    constructor() {\n      super();\n      const matDateLocale = inject(MAT_DATE_LOCALE, {\n        optional: true\n      });\n      if (matDateLocale !== undefined) {\n        this._matDateLocale = matDateLocale;\n      }\n      super.setLocale(this._matDateLocale);\n    }\n    getYear(date) {\n      return date.getFullYear();\n    }\n    getMonth(date) {\n      return date.getMonth();\n    }\n    getDate(date) {\n      return date.getDate();\n    }\n    getDayOfWeek(date) {\n      return date.getDay();\n    }\n    getMonthNames(style) {\n      const dtf = new Intl.DateTimeFormat(this.locale, {\n        month: style,\n        timeZone: 'utc'\n      });\n      return range(12, i => this._format(dtf, new Date(2017, i, 1)));\n    }\n    getDateNames() {\n      const dtf = new Intl.DateTimeFormat(this.locale, {\n        day: 'numeric',\n        timeZone: 'utc'\n      });\n      return range(31, i => this._format(dtf, new Date(2017, 0, i + 1)));\n    }\n    getDayOfWeekNames(style) {\n      const dtf = new Intl.DateTimeFormat(this.locale, {\n        weekday: style,\n        timeZone: 'utc'\n      });\n      return range(7, i => this._format(dtf, new Date(2017, 0, i + 1)));\n    }\n    getYearName(date) {\n      const dtf = new Intl.DateTimeFormat(this.locale, {\n        year: 'numeric',\n        timeZone: 'utc'\n      });\n      return this._format(dtf, date);\n    }\n    getFirstDayOfWeek() {\n      // At the time of writing `Intl.Locale` isn't available\n      // in the internal types so we need to cast to `any`.\n      if (typeof Intl !== 'undefined' && Intl.Locale) {\n        const locale = new Intl.Locale(this.locale);\n        // Some browsers implement a `getWeekInfo` method while others have a `weekInfo` getter.\n        // Note that this isn't supported in all browsers so we need to null check it.\n        const firstDay = (locale.getWeekInfo?.() || locale.weekInfo)?.firstDay ?? 0;\n        // `weekInfo.firstDay` is a number between 1 and 7 where, starting from Monday,\n        // whereas our representation is 0 to 6 where 0 is Sunday so we need to normalize it.\n        return firstDay === 7 ? 0 : firstDay;\n      }\n      // Default to Sunday if the browser doesn't provide the week information.\n      return 0;\n    }\n    getNumDaysInMonth(date) {\n      return this.getDate(this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + 1, 0));\n    }\n    clone(date) {\n      return new Date(date.getTime());\n    }\n    createDate(year, month, date) {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        // Check for invalid month and date (except upper bound on date which we have to check after\n        // creating the Date).\n        if (month < 0 || month > 11) {\n          throw Error(`Invalid month index \"${month}\". Month index has to be between 0 and 11.`);\n        }\n        if (date < 1) {\n          throw Error(`Invalid date \"${date}\". Date has to be greater than 0.`);\n        }\n      }\n      let result = this._createDateWithOverflow(year, month, date);\n      // Check that the date wasn't above the upper bound for the month, causing the month to overflow\n      if (result.getMonth() != month && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error(`Invalid date \"${date}\" for month with index \"${month}\".`);\n      }\n      return result;\n    }\n    today() {\n      return new Date();\n    }\n    parse(value, parseFormat) {\n      // We have no way using the native JS Date to set the parse format or locale, so we ignore these\n      // parameters.\n      if (typeof value == 'number') {\n        return new Date(value);\n      }\n      return value ? new Date(Date.parse(value)) : null;\n    }\n    format(date, displayFormat) {\n      if (!this.isValid(date)) {\n        throw Error('NativeDateAdapter: Cannot format invalid date.');\n      }\n      const dtf = new Intl.DateTimeFormat(this.locale, {\n        ...displayFormat,\n        timeZone: 'utc'\n      });\n      return this._format(dtf, date);\n    }\n    addCalendarYears(date, years) {\n      return this.addCalendarMonths(date, years * 12);\n    }\n    addCalendarMonths(date, months) {\n      let newDate = this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + months, this.getDate(date));\n      // It's possible to wind up in the wrong month if the original month has more days than the new\n      // month. In this case we want to go to the last day of the desired month.\n      // Note: the additional + 12 % 12 ensures we end up with a positive number, since JS % doesn't\n      // guarantee this.\n      if (this.getMonth(newDate) != ((this.getMonth(date) + months) % 12 + 12) % 12) {\n        newDate = this._createDateWithOverflow(this.getYear(newDate), this.getMonth(newDate), 0);\n      }\n      return newDate;\n    }\n    addCalendarDays(date, days) {\n      return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date) + days);\n    }\n    toIso8601(date) {\n      return [date.getUTCFullYear(), this._2digit(date.getUTCMonth() + 1), this._2digit(date.getUTCDate())].join('-');\n    }\n    /**\n     * Returns the given value if given a valid Date or null. Deserializes valid ISO 8601 strings\n     * (https://www.ietf.org/rfc/rfc3339.txt) into valid Dates and empty string into null. Returns an\n     * invalid date for all other values.\n     */\n    deserialize(value) {\n      if (typeof value === 'string') {\n        if (!value) {\n          return null;\n        }\n        // The `Date` constructor accepts formats other than ISO 8601, so we need to make sure the\n        // string is the right format first.\n        if (ISO_8601_REGEX.test(value)) {\n          let date = new Date(value);\n          if (this.isValid(date)) {\n            return date;\n          }\n        }\n      }\n      return super.deserialize(value);\n    }\n    isDateInstance(obj) {\n      return obj instanceof Date;\n    }\n    isValid(date) {\n      return !isNaN(date.getTime());\n    }\n    invalid() {\n      return new Date(NaN);\n    }\n    setTime(target, hours, minutes, seconds) {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (!inRange(hours, 0, 23)) {\n          throw Error(`Invalid hours \"${hours}\". Hours value must be between 0 and 23.`);\n        }\n        if (!inRange(minutes, 0, 59)) {\n          throw Error(`Invalid minutes \"${minutes}\". Minutes value must be between 0 and 59.`);\n        }\n        if (!inRange(seconds, 0, 59)) {\n          throw Error(`Invalid seconds \"${seconds}\". Seconds value must be between 0 and 59.`);\n        }\n      }\n      const clone = this.clone(target);\n      clone.setHours(hours, minutes, seconds, 0);\n      return clone;\n    }\n    getHours(date) {\n      return date.getHours();\n    }\n    getMinutes(date) {\n      return date.getMinutes();\n    }\n    getSeconds(date) {\n      return date.getSeconds();\n    }\n    parseTime(userValue, parseFormat) {\n      if (typeof userValue !== 'string') {\n        return userValue instanceof Date ? new Date(userValue.getTime()) : null;\n      }\n      const value = userValue.trim();\n      if (value.length === 0) {\n        return null;\n      }\n      // Attempt to parse the value directly.\n      let result = this._parseTimeString(value);\n      // Some locales add extra characters around the time, but are otherwise parseable\n      // (e.g. `00:05 ч.` in bg-BG). Try replacing all non-number and non-colon characters.\n      if (result === null) {\n        const withoutExtras = value.replace(/[^0-9:(AM|PM)]/gi, '').trim();\n        if (withoutExtras.length > 0) {\n          result = this._parseTimeString(withoutExtras);\n        }\n      }\n      return result || this.invalid();\n    }\n    addSeconds(date, amount) {\n      return new Date(date.getTime() + amount * 1000);\n    }\n    /** Creates a date but allows the month and date to overflow. */\n    _createDateWithOverflow(year, month, date) {\n      // Passing the year to the constructor causes year numbers <100 to be converted to 19xx.\n      // To work around this we use `setFullYear` and `setHours` instead.\n      const d = new Date();\n      d.setFullYear(year, month, date);\n      d.setHours(0, 0, 0, 0);\n      return d;\n    }\n    /**\n     * Pads a number to make it two digits.\n     * @param n The number to pad.\n     * @returns The padded number.\n     */\n    _2digit(n) {\n      return ('00' + n).slice(-2);\n    }\n    /**\n     * When converting Date object to string, javascript built-in functions may return wrong\n     * results because it applies its internal DST rules. The DST rules around the world change\n     * very frequently, and the current valid rule is not always valid in previous years though.\n     * We work around this problem building a new Date object which has its internal UTC\n     * representation with the local date and time.\n     * @param dtf Intl.DateTimeFormat object, containing the desired string format. It must have\n     *    timeZone set to 'utc' to work fine.\n     * @param date Date from which we want to get the string representation according to dtf\n     * @returns A Date object with its UTC representation based on the passed in date info\n     */\n    _format(dtf, date) {\n      // Passing the year to the constructor causes year numbers <100 to be converted to 19xx.\n      // To work around this we use `setUTCFullYear` and `setUTCHours` instead.\n      const d = new Date();\n      d.setUTCFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n      d.setUTCHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n      return dtf.format(d);\n    }\n    /**\n     * Attempts to parse a time string into a date object. Returns null if it cannot be parsed.\n     * @param value Time string to parse.\n     */\n    _parseTimeString(value) {\n      // Note: we can technically rely on the browser for the time parsing by generating\n      // an ISO string and appending the string to the end of it. We don't do it, because\n      // browsers aren't consistent in what they support. Some examples:\n      // - Safari doesn't support AM/PM.\n      // - Firefox produces a valid date object if the time string has overflows (e.g. 12:75) while\n      //   other browsers produce an invalid date.\n      // - Safari doesn't allow padded numbers.\n      const parsed = value.toUpperCase().match(TIME_REGEX);\n      if (parsed) {\n        let hours = parseInt(parsed[1]);\n        const minutes = parseInt(parsed[2]);\n        let seconds = parsed[3] == null ? undefined : parseInt(parsed[3]);\n        const amPm = parsed[4];\n        if (hours === 12) {\n          hours = amPm === 'AM' ? 0 : hours;\n        } else if (amPm === 'PM') {\n          hours += 12;\n        }\n        if (inRange(hours, 0, 23) && inRange(minutes, 0, 59) && (seconds == null || inRange(seconds, 0, 59))) {\n          return this.setTime(this.today(), hours, minutes, seconds || 0);\n        }\n      }\n      return null;\n    }\n    static ɵfac = function NativeDateAdapter_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NativeDateAdapter)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NativeDateAdapter,\n      factory: NativeDateAdapter.ɵfac\n    });\n  }\n  return NativeDateAdapter;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** Checks whether a number is within a certain range. */\nfunction inRange(value, min, max) {\n  return !isNaN(value) && value >= min && value <= max;\n}\nconst MAT_NATIVE_DATE_FORMATS = {\n  parse: {\n    dateInput: null,\n    timeInput: null\n  },\n  display: {\n    dateInput: {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric'\n    },\n    timeInput: {\n      hour: 'numeric',\n      minute: 'numeric'\n    },\n    monthYearLabel: {\n      year: 'numeric',\n      month: 'short'\n    },\n    dateA11yLabel: {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric'\n    },\n    monthYearA11yLabel: {\n      year: 'numeric',\n      month: 'long'\n    },\n    timeOptionLabel: {\n      hour: 'numeric',\n      minute: 'numeric'\n    }\n  }\n};\nlet NativeDateModule = /*#__PURE__*/(() => {\n  class NativeDateModule {\n    static ɵfac = function NativeDateModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NativeDateModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NativeDateModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [{\n        provide: DateAdapter,\n        useClass: NativeDateAdapter\n      }]\n    });\n  }\n  return NativeDateModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatNativeDateModule = /*#__PURE__*/(() => {\n  class MatNativeDateModule {\n    static ɵfac = function MatNativeDateModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatNativeDateModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: MatNativeDateModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [provideNativeDateAdapter()]\n    });\n  }\n  return MatNativeDateModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction provideNativeDateAdapter(formats = MAT_NATIVE_DATE_FORMATS) {\n  return [{\n    provide: DateAdapter,\n    useClass: NativeDateAdapter\n  }, {\n    provide: MAT_DATE_FORMATS,\n    useValue: formats\n  }];\n}\nexport { AnimationCurves, AnimationDurations, DateAdapter, MAT_DATE_FORMATS, MAT_DATE_LOCALE, MAT_NATIVE_DATE_FORMATS, MatNativeDateModule, NativeDateAdapter, NativeDateModule, VERSION, provideNativeDateAdapter };\n//# sourceMappingURL=core.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}